#
# Note that this file is called SConsUtils.py not SCons.py so as to allow us to import SCons
#
import os
import re
import SCons.Script
from SCons.Script.SConscript import SConsEnvironment

from .utils import memberOf

@memberOf(SConsEnvironment)
def SharedLibraryIncomplete(self, target, source, **keywords):
    """Like SharedLibrary, but don't insist that all symbols are resolved"""

    myenv = self.Clone()

    if myenv['PLATFORM'] == 'darwin':
        myenv['SHLINKFLAGS'] += ["-undefined", "suppress", "-flat_namespace"]

    return myenv.SharedLibrary(target, source, **keywords)

@memberOf(SConsEnvironment)
def LoadableModuleIncomplete(self, target, source, **keywords):
    """Like LoadableModule, but don't insist that all symbols are resolved"""

    myenv = self.Clone()
    if myenv['PLATFORM'] == 'darwin':
        myenv.Append(LDMODULEFLAGS = ["-undefined", "suppress", "-flat_namespace",])
    #
    # Swig-generated .cc files cast pointers to long longs and back,
    # which is illegal.  This flag tells g++ about the sin
    #
    try:
        if myenv.isGcc:
            myenv.Append(CCFLAGS = ["-fno-strict-aliasing",])
    except AttributeError:
        pass

    return myenv.LoadableModule(target, source, **keywords)

SConsEnvironment.SwigLoadableModule = LoadableModuleIncomplete

#-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

@memberOf(SConsEnvironment)
def SourcesForSharedLibrary(self, files):
    """Prepare the list of files to be passed to a SharedLibrary constructor

    In particular, ensure that any files listed in env.NoOptFiles (set by the command line option
    noOptFile="file1 file2") are built without optimisation and files listed in env.optFiles are
    built with optimisation
    
    The usage pattern in an SConscript file is:
    ccFiles = env.SourcesForSharedLibrary(glob.glob("../src/*/*.cc"))
    env.SharedLibrary('afw', ccFiles, LIBS=filter(lambda x: x != "afw", env.getlibs("afw")))
    """

    if not (self.get("optFiles") or self.get("noOptFiles")):
        return files

    if self.get("optFiles"):
        optFiles = self["optFiles"].replace(".", r"\.") # it'll be used in an RE
        optFiles = SCons.Script.Split(optFiles.replace(",", " "))
        optFilesRe = "/(%s)$" % "|".join(optFiles)
    else:
        optFilesRe = None

    if self.get("noOptFiles"):
        noOptFiles = self["noOptFiles"].replace(".", r"\.") # it'll be used in an RE
        noOptFiles = SCons.Script.Split(noOptFiles.replace(",", " "))
        noOptFilesRe = "/(%s)$" % "|".join(noOptFiles)
    else:
        noOptFilesRe = None

    if self.get("opt"):
        opt = int(self["opt"])
    else:
        opt = 0

    if opt == 0:
        opt = 3

    CCFLAGS_OPT = re.sub(r"-O(\d|s)\s*", "-O%d " % opt, str(self["CCFLAGS"]))
    CCFLAGS_NOOPT = re.sub(r"-O(\d|s)\s*", "-O0 ", str(self["CCFLAGS"])) # remove -O flags from CCFLAGS

    sources = []
    for ccFile in files:
        if optFilesRe and re.search(optFilesRe, ccFile):
            self.SharedObject(ccFile, CCFLAGS=CCFLAGS_OPT)
            ccFile = os.path.splitext(ccFile)[0] + self["SHOBJSUFFIX"]
        elif noOptFilesRe and re.search(noOptFilesRe, ccFile):
            self.SharedObject(ccFile, CCFLAGS=CCFLAGS_NOOPT)
            ccFile = os.path.splitext(ccFile)[0] + self["SHOBJSUFFIX"]

        sources.append(ccFile)

    return sources
    
#-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

def filesToTag(root=None, fileRegex=None, ignoreDirs=None):
    """Return a list of files that need to be scanned for tags, starting at directory root

    Files are chosen if they match fileRegex; toplevel directories in list ignoreDirs are ignored

    This routine won't do anything unless you specified a "TAGS" target
    """
    if root is None: root = "."
    if fileRegex is None: fileRegex = r"^[a-zA-Z0-9_].*\.(cc|h(pp)?|py)$"
    if ignoreDirs is None: ignoreDirs = ["examples", "tests"]

    if len(filter(lambda t: t == "TAGS", SCons.Script.COMMAND_LINE_TARGETS)) == 0:
        return []

    files = []
    for dirpath, dirnames, filenames in os.walk(root):
        if dirpath == ".":
            dirnames[:] = [d for d in dirnames if not re.search(r"^(%s)$" % "|".join(ignoreDirs), d)]

        dirnames[:] = [d for d in dirnames if not re.search(r"^(\.svn)$", d)] # ignore .svn tree
        #
        # List of possible files to tag, but there's some cleanup required for machine-generated files
        #
        candidates = [f for f in filenames if re.search(fileRegex, f)]
        #
        # Remove files generated by swig
        #
        for swigFile in [f for f in filenames if re.search(r"\.i$", f)]:
            name = os.path.splitext(swigFile)[0]
            candidates = [f for f in candidates if not re.search(r"%s(_wrap\.cc?|\.py)$" % name, f)]

        files += [os.path.join(dirpath, f) for f in candidates]

    return files

@memberOf(SConsEnvironment)
def BuildETags(env, root=None, fileRegex=None, ignoreDirs=None):
    toTag = filesToTag(root, fileRegex, ignoreDirs)
    if toTag:
        return env.Command("TAGS", files, "etags -o $TARGET $SOURCES")

#-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

@memberOf(SConsEnvironment)
def CleanTree(self, files, dir=".", recurse=True, verbose=False):
    """Remove files matching the argument list starting at dir
    when scons is invoked with -c/--clean and no explicit targets are listed
    
    E.g. CleanTree(r"*~ core")

    If recurse is True, recursively descend the file system; if
    verbose is True, print each filename after deleting it
    """
    #
    # Generate command that we may want to execute
    #
    files_expr = ""
    for file in SCons.Script.Split(files):
        if files_expr:
            files_expr += " -o "

        files_expr += "-name %s" % re.sub(r"(^|[^\\])([[*])", r"\1\\\2",file) # quote unquoted * and []
    #
    # don't use xargs --- who knows what needs quoting?
    #
    action = "find %s" % dir
    action += r" \( -name .svn -prune -o -name \* \) "
    if not recurse:
        action += " ! -name . -prune"

    file_action = "rm -f"

    action += r" \( %s \) -exec %s {} \;" % \
        (files_expr, file_action)

    if verbose:
        action += " -print"
    #
    # Clean up scons files --- users want to be able to say scons -c and get a clean copy
    # We can't delete .sconsign.dblite if we use "scons clean" instead of "scons --clean",
    # so the former is no longer supported.
    #
    action += " ; rm -rf .sconf_temp .sconsign.dblite .sconsign.tmp config.log" 
    #
    # Do we actually want to clean up?  We don't if the command is e.g. "scons -c install"
    #
    if "clean" in SCons.Script.COMMAND_LINE_TARGETS:
        state.log.fail("'scons clean' is no longer supported; please use 'scons --clean'.")
    elif not SCons.Script.COMMAND_LINE_TARGETS and self.GetOption("clean"):
        self.Execute(self.Action([action]))
