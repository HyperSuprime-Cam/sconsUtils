import os.path
import collections
import imp
import sys

from . import utils

def getPackageRoot(cfgFile):
    return os.path.abspath(os.path.join(os.path.dirname(cfgFile), ".."))

class Configuration(object):
    """Base class for defining how to configure an LSST sconsUtils package.

    An ups/*.cfg file should contain an instance of this class called
    "config".  Most LSST packages will be able to use this class directly
    instead of subclassing it.

    The only important method is configure(), which modifies an SCons
    environment to use the package.  If a subclass overrides configure,
    it may not need to call the base class __init__(), whose only
    purpose is to define a number of instance variables used by configure().
    """

    def __init__(self, name, root, headers=(), libs=None, hasSwigFiles=True, hasDoxygenInclude=False):
        """Initialize the configuration object.

        @param name     The name of the package.  This will be used to compute the names of
                        libraries and doxygen input files in a standard way.
        @param root     Root path for the package.
        @param headers  A list of headers provided by the package, to be used in autoconf-style tests.
        @param libs     A list or dictionary of libraries provided by the package.  If a dictionary
                        is provided, libs["main"] should contain a list of regular libraries provided
                        by the library.  Other keys are "python" and "test", which refer to libraries
                        that are only linked against compiled Python modules and unit tests, respectively.
                        If a list is provided, the list is used as "main".  These are used both for
                        autoconf-style tests and to support env.getLib(...), which recursively computes
                        the libraries a package must be linked with.
        @param hasDoxygenInclude   If True, the package provides a Doxygen include file with the
                                   name "<root>/doc/<name>.inc".
        """
        self.name = name
        self.root = root
        self.paths = {
            # Sequence of include path for headers provided by this package
            "CPPPATH": [os.path.join(self.root, "include")],
            # Sequence of library path for libraries provided by this package
            "LIBPATH": [os.path.join(self.root, "lib")],
            # Sequence of SWIG include paths for .i files provided by this package
            "SWIGPATH": ([os.path.join(self.root, "python")]
                         if hasSwigFiles else [])
            }
        self.doxygen = {
            # Doxygen tag files generated by this package
            "tags": [os.path.join(self.root, "doc", "%s.tag" % self.name)],
            # Doxygen include files to include in the configuration of dependent products
            "includes": ([os.path.join(self.root, "doc", "%s.tag" % self.name)]
                         if hasDoxygenInclude else [])
            }
        if libs is None:
            self.libs = {
                # Normal libraries provided by this package
                "main": [self.name],
                # Libraries provided that should only be linked with Python modules
                "python":[],
                # Libraries provided that should only be linked with unit test code
                "test":[],
                }
        elif "main" in libs:
            self.libs = libs
        else:
            self.libs = {"main": libs, "python": [], "test": []}
        self.provides = {
            "headers": tuple(headers),
            "libs": tuple(self.libs["main"])
            }

    def configure(self, conf, packages, check=False, build=True):
        """
        Update an SCons environment to make use of the package.

        Arguments:
        @param conf      An SCons Configure context.  The SCons Environment conf.env should be updated
                         by the configure function.
        @param packages  A dictionary containing the configuration modules of all dependencies (or None if
                         the dependency was optional and was not found).  The <module>.config.configure(...)
                         method will have already been called on all dependencies.
        @param check     If True, perform autoconf-style tests to verify that key components are in
                         fact in place.
        @param build     If True, this is the package currently being built, and packages in
                         "buildRequired" and "buildOptional" dependencies will also be present in
                         the packages dict.
        """
        assert(not (check and build))
        conf.env.PrependUnique(**self.paths)
        utils.log.info("Configuring package '%s'." % self.name)
        if not build:
            conf.env.doxygen["tags"].extend(self.doxygen["tags"])
            conf.env.doxygen["includes"].extend(self.doxygen["includes"])
        for target in self.libs:
            if target not in conf.env.libs:
                conf.env.libs[target] = lib[target].copy()
                utils.log.info("Adding '%s' libraries to target '%s'." % (self.libs[target], target))
            else:
                for lib in self.libs[target]:
                    if lib not in conf.env.libs[target]:
                        conf.env.libs[target].append(lib)
                        utils.log.info("Adding '%s' library to target '%s'." % (lib, target))
        if check:
            for header in self.provides["headers"]:
                if not conf.CheckCXXHeader(header): return False
            for lib in self.provides["headers"]:
                if not conf.CheckLib(lib, autoadd=False, language="C++"): return False
        return True
                

class Tree(object):
    """A class for loading and managing the dependency tree of a package, as defined by its
    configuration module (.cfg) file.

    This tree isn't actually stored as a tree; it's flattened into an ordered dictionary
    as it is recursively loaded.
    """

    def __init__(self, primaryName, upsDirs):
        """Recursively load *.cfg files for packageName and all its dependencies.

        @param primaryName      The name of the primary package being built.
        @param upsDirs          A list of "ups" directories for all setup EUPS packages, to be
                                searched for *.cfg files.

        After __init__, self.primary will be set to the configuration module for the primary package,
        and self.packages will be an OrderedDict of dependencies (excluding self.primary), ordered
        such that configuration can proceed in iteration order.
        """
        self.upsDirs = upsDirs
        self.packages = collections.OrderedDict()
        self.primary = self._tryImport(primaryName)
        if self.primary is None: fail("Failed to load primary package configuration.")
        for dependency in self.primary.dependencies.get("required", ()):
            if not self._recurse(dependency): utils.log.fail("Failed to load required dependencies.")
        for dependency in self.primary.dependencies.get("buildRequired", ()):
            if not self._recurse(dependency): utils.log.fail("Failed to load required build dependencies.")
        for dependency in self.primary.dependencies.get("optional", ()):
            self._recurse(dependency)
        for dependency in self.primary.dependencies.get("buildOptional", ()):
            self._recurse(dependency)

    def configure(self, env, check=False):
        """Configure the entire dependency tree in order. and return an updated environment."""
        conf = env.Configure()
        for module in self.packages.itervalues():
            if not module.config.configure(conf, packages=self.packages, check=check, build=False):
                utils.log.fail("Some dependencies were found but did not pass configuration checks.")
        self.primary.config.configure(conf, packages=self.packages, check=False, build=True)
        env.AppendUnique(SWIGPATH=env["CPPPATH"])
        env = conf.Finish()
        return env

    def _tryImport(self, name):
        """Search for and import an individual configuration module from file."""
        for path in self.upsDirs:
            filename = os.path.join(path, name + ".cfg")
            if os.path.exists(filename):
                utils.log.info("Using configuration for package '%s' at '%s'." % (name, filename))
                module = imp.load_source(name + "_cfg", filename)
                if not hasattr(module, "dependencies") or not isinstance(module.dependencies, dict):
                    utils.log.warn("Configuration module for package '%s' lacks a dependencies dict." % name)
                    return
                if not hasattr(module, "config") or not isinstance(module.config, Configuration):
                    utils.log.warn("Configuration module for package '%s' lacks a config object." % name)
                    return
                return module
        utils.log.warn("Failed to import configuration for package '%s'." % name)

    def _recurse(self, name):
        """Recursively load a dependency."""
        if name in self.packages:
            return self.packages[name] is not None
        module = self._tryImport(name)
        if module is None:
            self.packages[name] = None
            return False
        for dependency in module.dependencies.get("required", ()):
            if not self._recurse(dependency):
                # We can't configure this package because a required dependency wasn't found.
                # But this package might itself be optional, so we don't die yet.
                self.packages[name] = None
                utils.log.warn("Could not load all dependencies for package '%s'." % name)
                return False
        for dependency in module.dependencies.get("optional", ()):
            self._recurse(dependency)
        # This comes last to ensure the ordering puts all dependencies first.
        self.packages[name] = module
        return True
